package com.example.borrowingservice.controller;

import com.example.borrowingservice.client.ServiceClient;
import com.example.borrowingservice.dto.BookDTO;
import com.example.borrowingservice.dto.UserDTO;
import com.example.borrowingservice.exception.ResourceNotFoundException;
import com.example.borrowingservice.exception.ServiceUnavailableException;
import com.example.borrowingservice.model.Borrowing;
import com.example.borrowingservice.repository.BorrowingRepository;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.util.UriComponentsBuilder;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Positive;
import java.net.URI;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/borrowings")
@Validated
public class BorrowingController {

    private final BorrowingRepository borrowingRepository;
    private final ServiceClient serviceClient;

    public BorrowingController(BorrowingRepository borrowingRepository, ServiceClient serviceClient) {
        this.borrowingRepository = borrowingRepository;
        this.serviceClient = serviceClient;
    }

    @GetMapping
    public Flux<Borrowing> getBorrowings(
            @RequestParam(required = false) Long userId,
            @RequestParam(required = false) Long bookId) {
        
        if (userId != null) {
            return borrowingRepository.findByUserId(userId);
        } else if (bookId != null) {
            return borrowingRepository.findByBookId(bookId);
        } else {
            return borrowingRepository.findAll();
        }
    }

    @GetMapping("/{id}")
    public Mono<ResponseEntity<Borrowing>> getBorrowing(
            @PathVariable @NotNull(message = "Borrowing ID is required") Long id) {
        return borrowingRepository.findById(id)
                .map(ResponseEntity::ok)
                .switchIfEmpty(Mono.error(new ResourceNotFoundException("Borrowing not found with id: " + id)));
    }

    @GetMapping("/active")
    public Flux<Borrowing> getActiveBorrowings() {
        return borrowingRepository.findByReturned(false);
    }
    
    @GetMapping("/user/{userId}")
    public Flux<Borrowing> getBorrowingsByUser(@PathVariable Long userId) {
        return borrowingRepository.findByUserId(userId);
    }
    
    @GetMapping("/book/{bookId}")
    public Flux<Borrowing> getBorrowingsByBook(@PathVariable Long bookId) {
        return borrowingRepository.findByBookId(bookId);
    }

    @PostMapping
    public Mono<ResponseEntity<Borrowing>> createBorrowing(
            @RequestParam @NotNull(message = "Book ID is required") Long bookId,
            @RequestParam @NotNull(message = "User ID is required") Long userId,
            @RequestParam(defaultValue = "14") @Positive(message = "Days must be positive") int days,
            UriComponentsBuilder ucb) {
        
        Borrowing borrowing = new Borrowing(
            null, // ID will be generated by the database
            bookId,
            userId,
            LocalDate.now(),
            LocalDate.now().plusDays(days),
            false
        );
        
        return borrowingRepository.save(borrowing)
                .map(saved -> {
                    URI location = ucb.path("/api/borrowings/{id}")
                                    .buildAndExpand(saved.getId())
                                    .toUri();
                    return ResponseEntity.created(location).body(saved);
                });
    }

    @PutMapping("/{id}/return")
    public Mono<ResponseEntity<Borrowing>> returnBook(
            @PathVariable @NotNull(message = "Borrowing ID is required") Long id) {
        return borrowingRepository.findById(id)
                .flatMap(borrowing -> {
                    borrowing.setReturned(true);
                    borrowing.setReturnDate(LocalDate.now());
                    return borrowingRepository.save(borrowing)
                            .map(ResponseEntity::ok);
                })
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }

    @GetMapping("/details/{borrowingId}")
    public Mono<ResponseEntity<Map<String, Object>>> getBorrowingDetails(
            @PathVariable @NotNull(message = "Borrowing ID is required") Long borrowingId) {
        return borrowingRepository.findById(borrowingId)
            .flatMap(borrowing -> {
                // Get book and user details asynchronously
                Mono<BookDTO> bookMono = serviceClient.getBookDetailsAsync(borrowing.getBookId());
                Mono<UserDTO> userMono = serviceClient.getUserDetailsAsync(borrowing.getUserId());
                
                return Mono.zip(bookMono, userMono, (book, user) -> {
                    // Create response
                    Map<String, Object> response = new HashMap<>();
                    response.put("borrowing", borrowing);
                    response.put("book", book);
                    response.put("user", user);
                    return ResponseEntity.ok(response);
                });
            })
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
}
